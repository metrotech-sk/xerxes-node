#!/usr/bin/env python3
# -*- coding: utf-8 -*-


from pprint import pprint as print
import os
import time
import socket
import logging
import sys
from pymongo import MongoClient
from systemd import journal
from xerxes_node.hierarchy.branches.nivelation_branch import NivelationBranch
from xerxes_node.hierarchy.leaves.pleaf import PLeaf
from xerxes_node.network import Duplex, XerxesNetwork
import xerxes_node.config as config
from xerxes_node.parser import Parser
from xerxes_node.utils import get_cpu_temp_celsius


file_path = os.path.realpath(__file__)
script_dir = os.path.dirname(file_path)


import cppyy, os, time
cppyy.add_include_path(os.path.join(script_dir, "lib/include"))
[cppyy.include(i) for i in os.listdir(os.path.join(script_dir, "lib/include"))]
cppyy.add_library_path(os.path.join(script_dir, "build"))
cppyy.load_library("libxerxes")
from cppyy.gbl import Xerxes as X


HOSTNAME = socket.gethostname()

def home_dir(path):
    return os.path.join(os.path.expanduser("~"), path)



def run(db, network, sample_period, log_period):
    collection = db[HOSTNAME]

    current_period = log_period
    last_cycle = time.time()

    while True:
        while network.busy():
            pass
        network.poll()

        cycletime = time.time() - last_cycle
        try:
            time.sleep(sample_period-cycletime)
        except ValueError:
            log.warning(f"Cycle time {cycletime} is longer than sample period {sample_period}")

        last_cycle = time.time()
        current_period += sample_period
        
        if current_period >= log_period:
            current_period = 0
            
            for branch in network.branches:
                print(branch.read())

            data = {
                "measurement": sensor_data,
                "info": {
                    "units": "mm, Â°C",
                    "cpu_temp": get_cpu_temp_celsius()
                },           
                "time":{
                    "epoch": time.time(),
                    "gm_time": time.asctime(time.gmtime()),
                }     
            }

            new_id = collection.insert_one(data)
            log.info(f"New log pushed: {new_id.inserted_id}")
            log.debug(f"Data: {data}")


if __name__ == "__main__":
    
    print("creating logger")
    log_filename = "/tmp/xerxes.log"
    
    logging.basicConfig(
        format='%(asctime)s: %(name)s: %(levelname)s - %(message)s', 
        datefmt='%m/%d/%Y %I:%M:%S %p',
        filename=log_filename, 
        level=logging._nameToLevel[config.logging_level]
    )
    log = logging.getLogger(__name__)
    
    try:
        log.addHandler(journal.JournalHandler())
    except AttributeError:
        log.error("unable to open systemd journal, using stdout")
        
        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(logging.DEBUG)
        log.addHandler(handler)

    log.info(f"Logger started, log file: {log_filename}")

    rs485 = X.RS485(config.use_device)
    comm = X.Protocol(rs485, 0x00)
    
    # load sensor list from config
    branches = []
    
    for branch_name in config.branches:
        # parse branches from config according to their type
        branch = config.branches[branch_name]
        if branch["type"] == NivelationBranch:
            ref_leaf = PLeaf(
                channel=comm,
                medium=branch["medium"],
                my_addr=branch["reference_leaf"],
                std_timeout=branch["sensor_timeout"]
            
            )
            pleaves = PLeaf.from_list(
                channel=comm, 
                addresses=branch["leaves"],
                std_timeout=branch["sensor_timeout"],
                medium=branch["medium"]
                )
            
            branches.append(
                NivelationBranch(
                    leaves=pleaves,
                    name=branch_name,
                    reference_leaf=ref_leaf
                )
            )
        
    x_network = XerxesNetwork(
        branches=branches, 
        mode=Duplex.HALF, 
        std_timeout_s=config.network_timeout
        )

    shard = MongoClient(config.mongo_URI)
    database = shard.get_database(config.use_database)
    log.info(f"Database {database.name} connected")

    log.info(f"Using collection: {database.name}.{HOSTNAME}")
    log.debug(f"Current working dir: {os.getcwd()}")
  

    run(
        db=database, 
        network=x_network,
        sample_period=config.sample_period, 
        log_period=config.update_period
    )

